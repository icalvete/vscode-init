#!/bin/bash
#
# vscode-init - Inicializa proyectos con configuración para Claude Code
#
# Uso:
#   vscode-init <directorio>                    Inicializa proyecto básico
#   vscode-init <directorio> --ruby             Con convenciones Ruby
#   vscode-init <directorio> --rails            Con Ruby on Rails
#   vscode-init <directorio> --mcp-github       Con MCP de GitHub
#
# Ejemplos:
#   vscode-init ~/proyectos/mi-app
#   vscode-init ~/proyectos/mi-app --ruby
#   vscode-init ~/proyectos/mi-app --rails --mcp-github --mcp-postgres
#   vscode-init . --python

set -e

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Directorio del script (para encontrar templates)
# Resuelve symlinks para obtener la ruta real
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
TEMPLATE_DIR="$(dirname "$SCRIPT_DIR")/templates"

# Variables de flags
TARGET_DIR=""
FLAG_RUBY=false
FLAG_PYTHON=false
FLAG_JAVASCRIPT=false
FLAG_PHP=false
FLAG_CPP=false
FLAG_RAILS=false
FLAG_GODOT=false
FLAG_ARDUINO=false
ARDUINO_BOARD="uno"  # Default board para PlatformIO
FLAG_MCP_GITHUB=false
FLAG_MCP_POSTGRES=false

# Funciones de output
ok() { echo -e "${GREEN}✓${NC} $1"; }
info() { echo -e "${BLUE}→${NC} $1"; }
warn() { echo -e "${YELLOW}!${NC} $1"; }
error() { echo -e "${RED}✗${NC} $1" >&2; exit 1; }

show_help() {
    cat << 'EOF'
vscode-init - Inicializa proyectos con configuración para Claude Code

Uso:
  vscode-init <directorio> [opciones]

Opciones:
  --ruby          Añade convenciones Ruby (YARD, rubocop)
  --python        Añade convenciones Python (PEP8, docstrings)
  --javascript    Añade convenciones JavaScript (JSDoc, ESLint)
  --php           Añade convenciones PHP (PSR-12, PHPDoc)
  --cpp           Añade convenciones C/C++ (CMake, C++17/20)
  --rails         Añade convenciones Ruby on Rails
  --godot         Añade configuración para Godot Engine 4.x
  --arduino       Añade configuración para Arduino (PlatformIO)
  --board <name>  Placa Arduino/PlatformIO (default: uno)
                  Ejemplos: uno, esp32dev, nanoatmega328, megaatmega2560
  --mcp-github    Configura MCP para GitHub API
  --mcp-postgres  Configura MCP para PostgreSQL
  --help, -h      Muestra esta ayuda

Detección automática:
  - Godot: si encuentra project.godot
  - Arduino: si encuentra archivos .ino
  - C/C++: si encuentra CMakeLists.txt o Makefile

Ejemplos:
  vscode-init ~/proyectos/mi-app
  vscode-init ~/proyectos/mi-app --ruby
  vscode-init ~/proyectos/mi-app --rails --mcp-github
  vscode-init ~/proyectos/mi-juego --godot
  vscode-init . --python --javascript

Estructura generada:
  mi-proyecto/
  ├── CLAUDE.md              # Contexto del proyecto
  ├── .claude/
  │   └── commands/          # Comandos personalizados
  │       ├── document.md    # /document
  │       └── review.md      # /review
  └── .vscode/
      └── settings.json      # Settings del lenguaje

Más información: https://github.com/icalvete/vscode-init
EOF
}

# Validar directorio
validate_directory() {
    local dir="$1"

    # No permitir $HOME o /
    if [[ "$dir" == "$HOME" || "$dir" == "/" ]]; then
        error "No se puede inicializar en $dir (demasiado peligroso)"
    fi

    # Advertir si ya existe CLAUDE.md
    if [[ -f "$dir/CLAUDE.md" ]]; then
        warn "Ya existe CLAUDE.md en $dir"
        read -p "¿Sobrescribir? [s/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Ss]$ ]]; then
            error "Cancelado por el usuario"
        fi
    fi
}

# Resolver ruta absoluta
resolve_path() {
    local path="$1"

    # Expandir ~
    path="${path/#\~/$HOME}"

    # Convertir a absoluta
    if [[ "$path" != /* ]]; then
        path="$(pwd)/$path"
    fi

    echo "$path"
}

# Copiar template base de CLAUDE.md
copy_base() {
    local target="$1"
    local project_name="$(basename "$target")"

    info "Creando CLAUDE.md base..."

    # Crear CLAUDE.md con el nombre del proyecto
    sed "s/{PROJECT_NAME}/$project_name/g" "$TEMPLATE_DIR/claude-md/base.md" > "$target/CLAUDE.md"

    ok "CLAUDE.md creado"
}

# Añadir sección de lenguaje al CLAUDE.md
copy_language() {
    local target="$1"
    local lang="$2"

    if [[ -f "$TEMPLATE_DIR/claude-md/$lang.md" ]]; then
        info "Añadiendo sección $lang..."
        cat "$TEMPLATE_DIR/claude-md/$lang.md" >> "$target/CLAUDE.md"
        ok "Sección $lang añadida"
    else
        warn "Template $lang.md no encontrado"
    fi
}

# Copiar settings de VS Code
copy_vscode_settings() {
    local target="$1"
    local lang="$2"

    mkdir -p "$target/.vscode"

    if [[ -f "$TEMPLATE_DIR/vscode/$lang.json" ]]; then
        if [[ -f "$target/.vscode/settings.json" ]]; then
            # Merge con jq si está disponible
            if command -v jq &> /dev/null; then
                info "Mezclando settings de $lang..."
                jq -s '.[0] * .[1]' "$target/.vscode/settings.json" "$TEMPLATE_DIR/vscode/$lang.json" > "$target/.vscode/settings.json.tmp"
                mv "$target/.vscode/settings.json.tmp" "$target/.vscode/settings.json"
            else
                warn "jq no disponible, sobrescribiendo settings"
                cp "$TEMPLATE_DIR/vscode/$lang.json" "$target/.vscode/settings.json"
            fi
        else
            cp "$TEMPLATE_DIR/vscode/$lang.json" "$target/.vscode/settings.json"
        fi
        ok "Settings de $lang configurados"
    fi
}

# Copiar templates de Godot (estructura completa)
copy_godot_templates() {
    local target="$1"

    info "Configurando proyecto Godot..."

    # Copiar estructura .vscode completa
    if [[ -d "$TEMPLATE_DIR/godot/.vscode" ]]; then
        mkdir -p "$target/.vscode"

        # Copiar cada archivo individualmente, mergeando si es necesario
        for vscode_file in "$TEMPLATE_DIR/godot/.vscode"/*.json; do
            if [[ -f "$vscode_file" ]]; then
                local filename="$(basename "$vscode_file")"

                if [[ -f "$target/.vscode/$filename" ]] && command -v jq &> /dev/null; then
                    # Merge JSON si ya existe
                    info "Mezclando $filename con configuración Godot..."
                    jq -s '.[0] * .[1]' "$target/.vscode/$filename" "$vscode_file" > "$target/.vscode/$filename.tmp"
                    mv "$target/.vscode/$filename.tmp" "$target/.vscode/$filename"
                else
                    cp "$vscode_file" "$target/.vscode/$filename"
                fi
            fi
        done
        ok "Configuración .vscode de Godot aplicada"
    fi

    # Copiar .editorconfig si no existe
    if [[ -f "$TEMPLATE_DIR/godot/.editorconfig" ]] && [[ ! -f "$target/.editorconfig" ]]; then
        cp "$TEMPLATE_DIR/godot/.editorconfig" "$target/.editorconfig"
        ok ".editorconfig de Godot copiado"
    fi

    # Copiar o merge .gitignore
    if [[ -f "$TEMPLATE_DIR/godot/.gitignore" ]]; then
        if [[ -f "$target/.gitignore" ]]; then
            # Añadir al gitignore existente
            echo "" >> "$target/.gitignore"
            echo "# Godot" >> "$target/.gitignore"
            cat "$TEMPLATE_DIR/godot/.gitignore" | grep -v "^#" | grep -v "^$" >> "$target/.gitignore"
            ok ".gitignore actualizado con reglas de Godot"
        else
            cp "$TEMPLATE_DIR/godot/.gitignore" "$target/.gitignore"
            ok ".gitignore de Godot creado"
        fi
    fi
}

# Copiar comandos personalizados
copy_commands() {
    local target="$1"

    info "Copiando comandos personalizados..."

    mkdir -p "$target/.claude/commands"

    for cmd in "$TEMPLATE_DIR/commands"/*.md; do
        if [[ -f "$cmd" ]]; then
            cp "$cmd" "$target/.claude/commands/"
        fi
    done

    ok "Comandos personalizados disponibles"
}

# Configurar MCP
setup_mcp() {
    local target="$1"
    local mcp_type="$2"

    if [[ ! -f "$TEMPLATE_DIR/mcp/$mcp_type.json" ]]; then
        warn "Template MCP $mcp_type.json no encontrado"
        return
    fi

    info "Configurando MCP $mcp_type..."

    mkdir -p "$target/.claude"

    if [[ -f "$target/.claude/mcp.json" ]]; then
        # Merge con jq si está disponible
        if command -v jq &> /dev/null; then
            jq -s '{"mcpServers": (.[0].mcpServers + .[1].mcpServers)}' \
                "$target/.claude/mcp.json" \
                "$TEMPLATE_DIR/mcp/$mcp_type.json" > "$target/.claude/mcp.json.tmp"
            mv "$target/.claude/mcp.json.tmp" "$target/.claude/mcp.json"
        else
            warn "jq no disponible, sobrescribiendo MCP config"
            cp "$TEMPLATE_DIR/mcp/$mcp_type.json" "$target/.claude/mcp.json"
        fi
    else
        cp "$TEMPLATE_DIR/mcp/$mcp_type.json" "$target/.claude/mcp.json"
    fi

    ok "MCP $mcp_type configurado"

    # Advertencia sobre tokens
    if [[ "$mcp_type" == "github" ]]; then
        warn "Recuerda editar .claude/mcp.json y añadir tu GITHUB_TOKEN"
    elif [[ "$mcp_type" == "postgres" ]]; then
        warn "Recuerda editar .claude/mcp.json y configurar POSTGRES_URL"
    fi
}

# Inicializar proyecto PlatformIO
init_platformio() {
    local target="$1"
    local board="$2"

    info "Inicializando proyecto PlatformIO (board: $board)..."

    # Buscar comando pio
    local pio_cmd=""
    if command -v pio &> /dev/null; then
        pio_cmd="pio"
    elif [[ -f ~/.platformio/penv/bin/pio ]]; then
        pio_cmd="~/.platformio/penv/bin/pio"
    else
        warn "PlatformIO no encontrado, omitiendo inicialización PlatformIO"
        echo ""
        echo "Para instalar PlatformIO Core:"
        echo "  curl -fsSL https://raw.githubusercontent.com/platformio/platformio-core-installer/master/get-platformio.py -o get-platformio.py"
        echo "  python3 get-platformio.py"
        echo ""
        echo "O instala la extensión PlatformIO IDE en VS Code (recomendado):"
        echo "  code --install-extension platformio.platformio-ide"
        echo ""
        return 1
    fi

    # Ejecutar pio project init
    cd "$target" || error "No se pudo acceder al directorio $target"

    if eval "$pio_cmd project init --board $board" &> /dev/null; then
        ok "Proyecto PlatformIO inicializado con board: $board"

        # Crear main.cpp básico si no existe
        if [[ ! -f "$target/src/main.cpp" ]]; then
            mkdir -p "$target/src"
            cat > "$target/src/main.cpp" << 'EOF'
#include <Arduino.h>

// Pin del LED integrado
const int LED_PIN = LED_BUILTIN;

void setup() {
  // Inicializar pin del LED como salida
  pinMode(LED_PIN, OUTPUT);

  // Inicializar comunicación serial
  Serial.begin(9600);
  Serial.println("Sistema iniciado");
}

void loop() {
  // Encender LED
  digitalWrite(LED_PIN, HIGH);
  Serial.println("LED ON");
  delay(1000);

  // Apagar LED
  digitalWrite(LED_PIN, LOW);
  Serial.println("LED OFF");
  delay(1000);
}
EOF
            ok "Archivo src/main.cpp creado"
        fi
    else
        warn "Error al inicializar PlatformIO (board: $board)"
        echo "Verifica que la board '$board' sea válida con: pio boards"
        return 1
    fi

    cd - > /dev/null || true
}

# Mostrar resumen final
show_summary() {
    local target="$1"

    echo ""
    echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${GREEN}  Proyecto inicializado correctamente${NC}"
    echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    echo "Estructura creada:"
    echo ""

    # Mostrar árbol básico
    if [[ -f "$target/CLAUDE.md" ]]; then
        echo "  $target/"
        echo "  ├── CLAUDE.md"
    fi
    if [[ -d "$target/.claude" ]]; then
        echo "  ├── .claude/"
        if [[ -d "$target/.claude/commands" ]]; then
            echo "  │   └── commands/"
            echo "  │       ├── document.md"
            echo "  │       └── review.md"
        fi
        if [[ -f "$target/.claude/mcp.json" ]]; then
            echo "  │   └── mcp.json"
        fi
    fi
    if [[ -d "$target/.vscode" ]]; then
        echo "  └── .vscode/"
        echo "      └── settings.json"
    fi

    # Recolectar extensiones recomendadas
    local has_extensions=false
    local extensions=""

    if [[ "$FLAG_RUBY" == true && -f "$TEMPLATE_DIR/extensions/ruby.txt" ]]; then
        extensions+=$(grep -v "^#" "$TEMPLATE_DIR/extensions/ruby.txt" | grep -v "^$")$'\n'
        has_extensions=true
    fi
    if [[ "$FLAG_PYTHON" == true && -f "$TEMPLATE_DIR/extensions/python.txt" ]]; then
        extensions+=$(grep -v "^#" "$TEMPLATE_DIR/extensions/python.txt" | grep -v "^$")$'\n'
        has_extensions=true
    fi
    if [[ "$FLAG_JAVASCRIPT" == true && -f "$TEMPLATE_DIR/extensions/javascript.txt" ]]; then
        extensions+=$(grep -v "^#" "$TEMPLATE_DIR/extensions/javascript.txt" | grep -v "^$")$'\n'
        has_extensions=true
    fi
    if [[ "$FLAG_PHP" == true && -f "$TEMPLATE_DIR/extensions/php.txt" ]]; then
        extensions+=$(grep -v "^#" "$TEMPLATE_DIR/extensions/php.txt" | grep -v "^$")$'\n'
        has_extensions=true
    fi
    if [[ "$FLAG_CPP" == true && -f "$TEMPLATE_DIR/extensions/cpp.txt" ]]; then
        extensions+=$(grep -v "^#" "$TEMPLATE_DIR/extensions/cpp.txt" | grep -v "^$")$'\n'
        has_extensions=true
    fi
    if [[ "$FLAG_ARDUINO" == true && -f "$TEMPLATE_DIR/extensions/arduino.txt" ]]; then
        extensions+=$(grep -v "^#" "$TEMPLATE_DIR/extensions/arduino.txt" | grep -v "^$")$'\n'
        has_extensions=true
    fi

    if [[ "$has_extensions" == true ]]; then
        if ! command -v code &> /dev/null; then
            echo "Extensiones recomendadas:"
            echo "$extensions" | grep -v "^$" | while read -r ext; do
                echo "  - $ext"
            done
            echo ""
            warn "Comando 'code' no disponible. Instala las extensiones manualmente."
            echo ""
        else
            # Verificar qué extensiones faltan
            local installed_extensions=$(code --list-extensions 2>/dev/null)
            local missing_extensions=""
            local already_installed=""

            while IFS= read -r ext; do
                [[ -z "$ext" ]] && continue
                if echo "$installed_extensions" | grep -qi "^${ext}$"; then
                    already_installed+="  - $ext"$'\n'
                else
                    missing_extensions+="$ext"$'\n'
                fi
            done <<< "$extensions"

            # Mostrar extensiones ya instaladas
            if [[ -n "$already_installed" ]]; then
                echo "Extensiones ya instaladas:"
                echo -n "$already_installed"
                echo ""
            fi

            # Preguntar solo por las que faltan
            if [[ -n "$missing_extensions" ]]; then
                echo "Extensiones que faltan:"
                echo "$missing_extensions" | grep -v "^$" | while read -r ext; do
                    echo "  - $ext"
                done
                echo ""

                read -p "¿Instalar extensiones que faltan? [s/N] " -n 1 -r
                echo ""
                if [[ $REPLY =~ ^[Ss]$ ]]; then
                    echo ""
                    echo "$missing_extensions" | grep -v "^$" | while read -r ext; do
                        info "Instalando $ext..."
                        if code --install-extension "$ext" --force &> /dev/null; then
                            ok "$ext instalada"
                        else
                            warn "No se pudo instalar $ext"
                        fi
                    done
                    echo ""
                fi
            else
                ok "Todas las extensiones recomendadas ya están instaladas"
                echo ""
            fi
        fi
    fi

    echo "Próximos pasos:"
    echo "  1. cd $target"
    echo "  2. code ."
    echo "  3. Abre Claude Code: Ctrl+Shift+P → 'Claude Code: Open'"
    echo ""
}

# Parser de argumentos
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                exit 0
                ;;
            --ruby)
                FLAG_RUBY=true
                shift
                ;;
            --python)
                FLAG_PYTHON=true
                shift
                ;;
            --javascript|--js)
                FLAG_JAVASCRIPT=true
                shift
                ;;
            --php)
                FLAG_PHP=true
                shift
                ;;
            --cpp|--c++)
                FLAG_CPP=true
                shift
                ;;
            --rails)
                FLAG_RAILS=true
                FLAG_RUBY=true  # Rails implica Ruby
                shift
                ;;
            --godot)
                FLAG_GODOT=true
                shift
                ;;
            --arduino)
                FLAG_ARDUINO=true
                shift
                ;;
            --board)
                if [[ -n "$2" && "$2" != -* ]]; then
                    ARDUINO_BOARD="$2"
                    shift 2
                else
                    error "--board requiere un argumento (ej: --board esp32dev)"
                fi
                ;;
            --mcp-github)
                FLAG_MCP_GITHUB=true
                shift
                ;;
            --mcp-postgres)
                FLAG_MCP_POSTGRES=true
                shift
                ;;
            -*)
                error "Opción desconocida: $1"
                ;;
            *)
                if [[ -z "$TARGET_DIR" ]]; then
                    TARGET_DIR="$1"
                else
                    error "Solo se permite un directorio"
                fi
                shift
                ;;
        esac
    done

    # Validar que se proporcionó directorio
    if [[ -z "$TARGET_DIR" ]]; then
        error "Falta directorio. Uso: vscode-init <directorio> [opciones]"
    fi
}

# Main
main() {
    parse_args "$@"

    # Resolver ruta
    TARGET_DIR="$(resolve_path "$TARGET_DIR")"

    # Validar
    validate_directory "$TARGET_DIR"

    # Crear directorio si no existe
    mkdir -p "$TARGET_DIR"

    # Detección automática de Godot
    if [[ -f "$TARGET_DIR/project.godot" ]]; then
        info "Proyecto Godot detectado (project.godot encontrado)"
        FLAG_GODOT=true
    fi

    # Detección automática de Arduino
    if compgen -G "$TARGET_DIR/*.ino" > /dev/null 2>&1; then
        info "Proyecto Arduino detectado (archivos .ino encontrados)"
        FLAG_ARDUINO=true
    fi

    # Detección automática de C/C++
    if [[ -f "$TARGET_DIR/CMakeLists.txt" ]] || [[ -f "$TARGET_DIR/Makefile" ]]; then
        info "Proyecto C/C++ detectado (CMakeLists.txt o Makefile encontrado)"
        FLAG_CPP=true
    fi

    echo ""
    info "Inicializando proyecto en: $TARGET_DIR"
    echo ""

    # Copiar base
    copy_base "$TARGET_DIR"

    # Copiar lenguajes
    if [[ "$FLAG_RUBY" == true ]]; then
        copy_language "$TARGET_DIR" "ruby"
        copy_vscode_settings "$TARGET_DIR" "ruby"
    fi

    if [[ "$FLAG_PYTHON" == true ]]; then
        copy_language "$TARGET_DIR" "python"
        copy_vscode_settings "$TARGET_DIR" "python"
    fi

    if [[ "$FLAG_JAVASCRIPT" == true ]]; then
        copy_language "$TARGET_DIR" "javascript"
        copy_vscode_settings "$TARGET_DIR" "javascript"
    fi

    if [[ "$FLAG_PHP" == true ]]; then
        copy_language "$TARGET_DIR" "php"
        copy_vscode_settings "$TARGET_DIR" "php"
    fi

    if [[ "$FLAG_CPP" == true ]]; then
        copy_language "$TARGET_DIR" "cpp"
        copy_vscode_settings "$TARGET_DIR" "cpp"
    fi

    # Copiar frameworks
    if [[ "$FLAG_RAILS" == true ]]; then
        copy_language "$TARGET_DIR" "rails"
    fi

    # Copiar configuración Godot
    if [[ "$FLAG_GODOT" == true ]]; then
        copy_language "$TARGET_DIR" "godot"
        copy_godot_templates "$TARGET_DIR"
    fi

    # Copiar configuración Arduino
    if [[ "$FLAG_ARDUINO" == true ]]; then
        # Inicializar PlatformIO primero (si está disponible)
        init_platformio "$TARGET_DIR" "$ARDUINO_BOARD"

        # Luego copiar templates y settings
        copy_language "$TARGET_DIR" "arduino"
        copy_vscode_settings "$TARGET_DIR" "arduino"
    fi

    # Copiar comandos
    copy_commands "$TARGET_DIR"

    # Configurar MCP
    if [[ "$FLAG_MCP_GITHUB" == true ]]; then
        setup_mcp "$TARGET_DIR" "github"
    fi

    if [[ "$FLAG_MCP_POSTGRES" == true ]]; then
        setup_mcp "$TARGET_DIR" "postgres"
    fi

    # Resumen
    show_summary "$TARGET_DIR"
}

main "$@"
